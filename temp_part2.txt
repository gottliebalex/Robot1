              new Pose2d(
                  blueBase.getTranslation().plus(normalOffset).plus(bluerightOffset), inward);
          blueSideMap.put(PipeSide.RIGHT, blueRight);

          Pose2d redRight =
              redBase.plus(
                  new Transform2d(new Translation2d(standoff, +halfSpacingM), new Rotation2d()));

          redSideMap.put(PipeSide.RIGHT, redRight);

          SCORING_SIDE_BLUE.get(br).put(lvl, blueSideMap);
          SCORING_SIDE_RED.get(br).put(lvl, redSideMap);
        }
      }

      // Initialize current views to the cached alliance once
      onAllianceUpdated(FieldConstants.getAllianceCached());
    }

    /** Returns the BLUE-reference face-center pose (position + facing) for a branch. */
    public static Pose2d blueFacePose(Branch branch) {
      return FACE_POSES_BLUE.get(branch);
    }

    public static Pose2d scoringPose(Branch branch, int level) {
      if (CURRENT_SCORING_NO_SIDE != null) {
        Level lvl = Level.fromInt(level);
        return CURRENT_SCORING_NO_SIDE.get(branch).get(lvl);
      }
      Pose2d blue = blueFacePose(branch);
      double standoff =
          switch (level) {
            case 1 -> STANDOFF_L1;
            case 2 -> STANDOFF_L2;
            case 3 -> STANDOFF_L3;
            default -> STANDOFF_L4;
          };
      // Place target in front of the face (outside the reef) along the face normal
      Translation2d offset = new Translation2d(standoff, 0).rotateBy(blue.getRotation());
      // Desired scoring orientation faces the reef (inward: normal + 180°)
      Pose2d blueWithOffsetInward =
          new Pose2d(
              blue.getTranslation().plus(offset),
              blue.getRotation().plus(Rotation2d.fromDegrees(180)));

      // Flip for RED
      Alliance alliance = DriverStation.getAlliance().orElse(Alliance.Blue);
      return alliance == Alliance.Red ? allianceFlip(blueWithOffsetInward) : blueWithOffsetInward;
      // we should look into using alliancefliputil
    }
    /*
    Scoring pose offset to the selected pipe side (left/right) relative to the face center. The
    offset is applied in the BLUE frame and then alliance-flipped if needed.
    */
    public static Pose2d scoringPose(Branch branch, int level, PipeSide side) {
      if (CURRENT_SCORING_SIDE != null) {
        Level lvl = Level.fromInt(level);
        return CURRENT_SCORING_SIDE.get(branch).get(lvl).get(side);
      }
      Pose2d blue = blueFacePose(branch);

      // Standoff along face normal (positive is away from reef)
      double standoff =
          switch (level) {
            case 1 -> STANDOFF_L1;
            case 2 -> STANDOFF_L2;
            case 3 -> STANDOFF_L3;
            default -> STANDOFF_L4;
          };
      Translation2d normalOffset = new Translation2d(standoff, 0).rotateBy(blue.getRotation());

      // Robot should face inward (toward the reef)
      Rotation2d inward = blue.getRotation().plus(Rotation2d.fromDegrees(180));

      // Lateral offset to the chosen pipe: half of the pipe center spacing, left is +90° from
      // inward, right is -90°
      double halfSpacingM = inchesToMeters(12.938) / 2.0;
      Rotation2d leftDir = inward.plus(Rotation2d.fromDegrees(90));
      Translation2d lateralOffset;
      if (side == PipeSide.CENTER) {
        lateralOffset = new Translation2d();
      } else {
        double sign = (side == PipeSide.LEFT) ? +1.0 : -1.0;
        lateralOffset = new Translation2d(sign * halfSpacingM, 0).rotateBy(leftDir);
      }

      Pose2d blueTarget =
          new Pose2d(blue.getTranslation().plus(normalOffset).plus(lateralOffset), inward);

      // Alliance-aware flip
      Alliance alliance = DriverStation.getAlliance().orElse(Alliance.Blue);
      return alliance == Alliance.Red ? allianceFlip(blueTarget) : blueTarget;
    }

    /*Finds the nearest reef branch (by face center) to a given field pose
     */
    public static Branch nearestBranch(Pose2d robotPose) {
      if (CURRENT_FACE_POSES != null) {
        Branch best = Branch.A;
        double bestDist = Double.POSITIVE_INFINITY;
        for (var e : CURRENT_FACE_POSES.entrySet()) {
          Translation2d fc = e.getValue().getTranslation();
          double d = robotPose.getTranslation().getDistance(fc);
          if (d < bestDist) {
            bestDist = d;
            best = e.getKey();
          }
        }
        return best;
      }
      Branch best = Branch.A;
      double bestDist = Double.POSITIVE_INFINITY;
      for (var e : FACE_CENTERS_BLUE.entrySet()) {
        Translation2d fc = e.getValue();
        double d =
            robotPose
                .getTranslation()
                .getDistance(
                    DriverStation.getAlliance().orElse(Alliance.Blue) == Alliance.Red
                        ? allianceFlip(new Pose2d(fc, new Rotation2d())).getTranslation()
                        : fc);
        if (d < bestDist) {
          bestDist = d;
          best = e.getKey();
        }
      }
      return best;
    }

    /* Updates current cached maps when alliance changes
    (I don't see when that would happen but why not put it in.). */
    static void onAllianceUpdated(Alliance alliance) {
      boolean isRed = alliance == Alliance.Red;
      CURRENT_FACE_POSES = isRed ? FACE_POSES_RED : FACE_POSES_BLUE;
      CURRENT_SCORING_NO_SIDE = isRed ? SCORING_NO_SIDE_RED : SCORING_NO_SIDE_BLUE;
      CURRENT_SCORING_SIDE = isRed ? SCORING_SIDE_RED : SCORING_SIDE_BLUE;
    }

    private static Pose2d allianceFlip(Pose2d bluePose) {
      // Mirror across the field X-length centerline (x -> L - x) and reflect heading.
      // For a reflection across the vertical centerline, the heading transforms as (pi - theta).
      double x = (FIELD_LENGTH) - bluePose.getX();
      double y = bluePose.getY();
      Rotation2d rot = Rotation2d.fromRadians(Math.PI).minus(bluePose.getRotation());
      return new Pose2d(x, y, rot);
    }
  }

  // April tag IDs
  public static final int RED_LEFT_CORAL_STATION = 1;
  public static final int RED_RIGHT_CORAL_STATION = 2;
  public static final int RED_PROCESSOR = 3;
  public static final int RED_RIGHT_NET = 4;
  public static final int RED_LEFT_NET = 5;
  public static final int RED_REEF_LEFT_DRIVER_STATION = 6;
  public static final int RED_REEF_CENTER_DRIVER_STATION = 7;
  public static final int RED_REEF_RIGHT_DRIVER_STATION = 8;
  public static final int RED_REEF_RIGHT_BARGE = 9;
  public static final int RED_REEF_CENTER_BARGE = 10;
  public static final int RED_REEF_LEFT_BARGE = 11;
  public static final int BLUE_RIGHT_CORAL_STATION = 12;
  public static final int BLUE_LEFT_CORAL_STATION = 13;
  public static final int BLUE_LEFT_BARGE = 14;
  public static final int BLUE_RIGHT_BARGE = 15;
  public static final int BLUE_PROCESSOR = 16;
  public static final int BLUE_REEF_RIGHT_DRIVER_STATION = 17;
  public static final int BLUE_REEF_CENTER_DRIVER_STATION = 18;
  public static final int BLUE_REEF_LEFT_DRIVER_STATION = 19;
  public static final int BLUE_REEF_RIGHT_BARGE = 20;
  public static final int BLUE_REEF_CENTER_BARGE = 21;
  public static final int BLUE_REEF_LEFT_BARGE = 22;

  public static boolean isBlueAlliance() {
    return getAllianceCached() == DriverStation.Alliance.Blue;
  }

  public static final Pose2d LEFT_STARTING_POSE_BLUE =
      new Pose2d(7.07, 7, Rotation2d.fromDegrees(0));
  public static final Pose2d LEFT_STARTING_POSE_RED =
      new Pose2d(
          FIELD_LENGTH - LEFT_STARTING_POSE_BLUE.getX(),
          FIELD_HEIGHT - LEFT_STARTING_POSE_BLUE.getY(),
          Rotation2d.fromDegrees(180));

  public static final Pose2d RIGHT_STARTING_POSE_BLUE =
      new Pose2d(
          LEFT_STARTING_POSE_BLUE.getX(),
          FIELD_HEIGHT - LEFT_STARTING_POSE_BLUE.getY(),
          Rotation2d.fromDegrees(0));
  public static final Pose2d RIGHT_STARTING_POSE_RED =
      new Pose2d(
          FIELD_LENGTH - RIGHT_STARTING_POSE_BLUE.getX(),
          FIELD_HEIGHT - RIGHT_STARTING_POSE_BLUE.getY(),
          Rotation2d.fromDegrees(180));
}
